import User, {IUser} from './User';

// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IGetTokenInfoResponse {
    User: IUser;
    access_token: string;
    expires: string;
    valid: boolean;
}

export default class GetTokenInfoResponse {
    readonly _User: User;

    get User(): User {
        return this._User;
    }

    readonly _access_token: string;

    get accessToken(): string {
        return this._access_token;
    }

    static accessTokenValidate(accessToken: string): boolean {
        return typeof accessToken === 'string' && !!accessToken.trim();
    }

    readonly _expires: string;

    get expires(): string {
        return this._expires;
    }

    static expiresValidate(expires: string): boolean {
        return typeof expires === 'string' && !!expires.trim();
    }

    readonly _valid: boolean;

    get valid(): boolean {
        return this._valid;
    }

    static validValidate(valid: boolean): boolean {
        return typeof valid === 'boolean';
    }

    constructor(props: IGetTokenInfoResponse) {
        this._User = new User(props.User);
        this._access_token = props.access_token.trim();
        this._expires = props.expires.trim();
        this._valid = props.valid;
    }

    serialize(): IGetTokenInfoResponse {
        const data: IGetTokenInfoResponse = {
            User: this._User.serialize(),
            access_token: this._access_token,
            expires: this._expires,
            valid: this._valid,
        };
        return data;
    }

    validate(): string[] {
        const validate = {
            access_token:
                typeof this._access_token === 'string' && !this._access_token
                    ? true
                    : this._access_token,
            expires:
                typeof this._expires === 'string' && !this._expires
                    ? true
                    : this._expires,
            valid: typeof this._valid === 'boolean',
            User: this._User.validate().length === 0,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props: Partial<IGetTokenInfoResponse>): GetTokenInfoResponse {
        return new GetTokenInfoResponse({...this.serialize(), ...props});
    }
}
